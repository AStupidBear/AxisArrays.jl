{
    "docs": [
        {
            "location": "/", 
            "text": "AxisArrays\n\n\n \n\n\nThis package for the Julia language provides an array type (the \nAxisArray\n) that knows about its dimension names and axis values. This allows for indexing with the axis name without incurring any runtime overhead. AxisArrays can also be indexed by the values of their axes, allowing column names or interval selections. This permits one to implement algorithms that are oblivious to the storage order of the underlying arrays. In contrast to similar approaches in \nImages.jl\n and \nNamedArrays.jl\n, this allows for type-stable selection of dimensions and compile-time axis lookup.  It is also better suited for regularly sampled axes, like samples over time.\n\n\nCollaboration is welcome! This is still a work-in-progress. See \nthe roadmap\n for the project's current direction.\n\n\n\n\nExample of currently-implemented behavior:\n\n\njulia\n Pkg.add(\nAxisArrays\n)\njulia\n using AxisArrays, Unitful\njulia\n import Unitful: s, ms, \u00b5s\n\njulia\n rng = MersenneTwister(123) # Seed a random number generator for repeatable examples\njulia\n fs = 40000 # Generate a 40kHz noisy signal, with spike-like stuff added for testing\njulia\n y = randn(rng, 60*fs+1)*3\njulia\n for spk = (sin.(0.8:0.2:8.6) .* [0:0.01:.1; .15:.1:.95; 1:-.05:.05] .* 50,\n                  sin.(0.8:0.4:8.6) .* [0:0.02:.1; .15:.1:1; 1:-.2:.1] .* 50)\n           i = rand(rng, round(Int,.001fs):1fs)\n           while i+length(spk)-1 \n length(y)\n               y[i:i+length(spk)-1] += spk\n               i += rand(rng, round(Int,.001fs):1fs)\n           end\n       end\n\n\n\n\njulia\n A = AxisArray([y 2y], Axis{:time}(0s:1s/fs:60s), Axis{:chan}([:c1, :c2]))\n\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time, 0.0 s:2.5e-5 s:60.0 s\n    :chan, Symbol[:c1, :c2]\nAnd data, a 2400001\u00d72 Array{Float64,2}:\n  3.5708     7.14161\n  6.14454   12.2891\n  3.42795    6.85591\n  1.37825    2.75649\n -1.19004   -2.38007\n -1.99414   -3.98828\n  2.9429     5.88581\n -0.226449  -0.452898\n  0.821446   1.64289\n -0.582687  -1.16537\n  \u22ee\n -3.50593   -7.01187\n  2.26783    4.53565\n -0.16902   -0.33804\n -3.84852   -7.69703\n  0.226457   0.452914\n  0.560809   1.12162\n  4.67663    9.35326\n -2.41005   -4.8201\n -3.71612   -7.43224\n\n\n\n\n\nAxisArrays behave like regular arrays, but they additionally use the axis information to enable all sorts of fancy behaviors. For example, we can specify indices in \nany\n order, just so long as we annotate them with the axis name:\n\n\njulia\n A[Axis{:time}(4)]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :chan, Symbol[:c1, :c2]\nAnd data, a 2-element Array{Float64,1}:\n 1.37825\n 2.75649\n\njulia\n A[Axis{:chan}(:c2), Axis{:time}(1:5)]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 0.0 s:2.5e-5 s:0.0001 s\nAnd data, a 5-element Array{Float64,1}:\n  7.14161\n 12.2891\n  6.85591\n  2.75649\n -2.38007\n\n\n\n\n\nWe can also index by the \nvalues\n of each axis using an \nInterval\n type that selects all values between two endpoints \na .. b\n or the axis values directly. Notice that the returned AxisArray still has axis information itself... and it still has the correct time information for those datapoints!\n\n\njulia\n A[40\u00b5s .. 220\u00b5s, :c1]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 5.0e-5 s:2.5e-5 s:0.0002 s\nAnd data, a 7-element Array{Float64,1}:\n  3.42795\n  1.37825\n -1.19004\n -1.99414\n  2.9429\n -0.226449\n  0.821446\n\njulia\n axes(ans, 1)\nAxisArrays.Axis{:time,StepRangeLen{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}},Base.TwicePrecision{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}},Base.TwicePrecision{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}}}}(5.0e-5 s:2.5e-5 s:0.0002 s)\n\n\n\n\n\nYou can also index by a single value on an axis using \natvalue\n. This will drop a dimension. Indexing with an \nInterval\n type retains dimensions, even when the ends of the interval are equal:\n\n\njulia\n A[atvalue(2.5e-5s), :c1]\n6.14453912336772\n\njulia\n A[2.5e-5s..2.5e-5s, :c1]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 2.5e-5 s:2.5e-5 s:2.5e-5 s\nAnd data, a 1-element Array{Float64,1}:\n 6.14454\n\n\n\n\n\nYou can even index by multiple values by broadcasting \natvalue\n over an array:\n\n\njulia\n A[atvalue.([2.5e-5s, 75.0\u00b5s])]\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time, Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}[2.5e-5 s, 7.5e-5 s]\n    :chan, Symbol[:c1, :c2]\nAnd data, a 2\u00d72 Array{Float64,2}:\n 6.14454  12.2891\n 1.37825   2.75649\n\n\n\n\n\nSometimes, though, what we're really interested in is a window of time about a specific index. One of the operations above (looking for values in the window from 40\u00b5s to 220\u00b5s) might be more clearly expressed as a symmetrical window about a specific index where we know something interesting happened. To represent this, we use the \natindex\n function:\n\n\njulia\n A[atindex(-90\u00b5s .. 90\u00b5s, 5), :c2]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time_sub, -7.5e-5 s:2.5e-5 s:7.5e-5 s\nAnd data, a 7-element Array{Float64,1}:\n 12.2891\n  6.85591\n  2.75649\n -2.38007\n -3.98828\n  5.88581\n -0.452898\n\n\n\n\n\nNote that the returned AxisArray has its time axis shifted to represent the interval about the given index!  This simple concept can be extended to some very powerful behaviors. For example, let's threshold our data and find windows about those threshold crossings.\n\n\njulia\n idxs = find(diff(A[:,:c1] .\n -15) .\n 0);\n\njulia\n spks = A[atindex(-200\u00b5s .. 800\u00b5s, idxs), :c1]\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time_sub, -0.0002 s:2.5e-5 s:0.0008 s\n    :time_rep, Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}[0.162 s, 0.20045 s, 0.28495 s, 0.530325 s, 0.821725 s, 1.0453 s, 1.11967 s, 1.1523 s, 1.22085 s, 1.6253 s  \u2026  57.0094 s, 57.5818 s, 57.8716 s, 57.8806 s, 58.4353 s, 58.7041 s, 59.1015 s, 59.1783 s, 59.425 s, 59.5657 s]\nAnd data, a 41\u00d7247 Array{Float64,2}:\n  -1.82238     2.3315      -1.56147   \u2026    4.33751     4.77713    -1.81713\n   0.672063    7.25649      0.633375       1.54583     5.81194    -4.706\n  -1.65182     2.57487      0.477408       3.09505     3.52478     4.13037\n   4.46035     2.11313      4.78372        1.23385     7.2525      3.57485\n   5.25651    -2.19785      3.05933        0.965021    6.78414     5.94854\n   7.8537      0.345008     0.960533  \u2026    0.812989    0.336715    0.303909\n   0.466816    0.643649    -3.67087        3.92978    -3.1242      0.789722\n  -6.0445    -13.2441      -4.60716        0.265144   -4.50987    -8.84897\n  -9.21703   -13.2254     -14.4409        -8.6664    -13.3457    -11.6213\n -16.1809    -22.7037     -25.023        -15.9376    -28.0817    -16.996\n   \u22ee                                  \u22f1                \u22ee\n   1.72728     4.77428    -10.3922        -2.08555     1.19198    -1.94365\n  -0.301629    0.0683982   -4.36574        1.92362    -5.12333    -3.4431\n   4.7182      1.18615      4.40717       -4.51757    -8.64314     0.0800021\n  -2.43775    -0.151882    -1.40817   \u2026   -3.38555    -2.23418     0.728549\n   3.2482     -0.60967      0.471288       2.53395     0.468817   -3.65905\n  -4.26967     2.24747     -3.13758        1.74967     4.5052     -0.145357\n  -0.752487    1.69446     -1.20491        1.71429     1.81936     0.290158\n   4.64348    -3.94187     -1.59213        7.15428    -0.539748    4.82309\n   1.09652    -2.66999      0.521931  \u2026   -3.80528     1.70421     3.40583\n\n\n\n\n\nBy indexing with a repeated interval, we have \nadded\n a dimension to the output! The returned AxisArray's columns specify each repetition of the interval, and each datapoint in the column represents a timepoint within that interval, adjusted by the time of the theshold crossing. The best part here is that the returned matrix knows precisely where its data came from, and has labeled its dimensions appropriately. Not only is there the proper time base for each waveform, but we also have recorded the event times as the axis across the columns.\n\n\n\n\nIndexing\n\n\n\n\nIndexing axes\n\n\nTwo main types of Axes supported by default include:\n\n\n\n\nCategorical axis \u2013 These are vectors of labels, normally symbols or strings. Elements or slices can be selected by elements or vectors of elements.\n\n\nDimensional axis \u2013 These are sorted vectors or iterators that can be selected by \nIntervals\n. These are commonly used for sequences of times or date-times. For regular sample rates, ranges can be used.\n\n\n\n\nHere is an example with a Dimensional axis representing a time sequence along rows and a Categorical axis of symbols for column headers.\n\n\nB = AxisArray(reshape(1:15, 5, 3), .1:.1:0.5, [:a, :b, :c])\nB[Axis{:row}(Interval(.2,.4))] # restrict the AxisArray along the time axis\nB[Interval(0.,.3), [:a, :c]]   # select an interval and two of the columns\n\n\n\n\nUser-defined axis types can be added along with custom indexing behaviors.\n\n\n\n\nExample: compute the intensity-weighted mean along the z axis\n\n\nB = AxisArray(randn(100,100,100), :x, :y, :z)\nItotal = sumz = 0.0\nfor iter in eachindex(B)  # traverses in storage order for cache efficiency\n    I = B[iter]  # intensity in a single voxel\n    Itotal += I\n    sumz += I * iter[axisdim(B, Axis{:z})]  # axisdim \nlooks up\n the z dimension\nend\nmeanz = sumz/Itotal\n\n\n\n\nThe intention is that all of these operations are just as efficient as they would be if you used traditional position-based indexing with all the inherent assumptions about the storage order of \nB\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#axisarrays", 
            "text": "This package for the Julia language provides an array type (the  AxisArray ) that knows about its dimension names and axis values. This allows for indexing with the axis name without incurring any runtime overhead. AxisArrays can also be indexed by the values of their axes, allowing column names or interval selections. This permits one to implement algorithms that are oblivious to the storage order of the underlying arrays. In contrast to similar approaches in  Images.jl  and  NamedArrays.jl , this allows for type-stable selection of dimensions and compile-time axis lookup.  It is also better suited for regularly sampled axes, like samples over time.  Collaboration is welcome! This is still a work-in-progress. See  the roadmap  for the project's current direction.", 
            "title": "AxisArrays"
        }, 
        {
            "location": "/#example-of-currently-implemented-behavior", 
            "text": "julia  Pkg.add( AxisArrays )\njulia  using AxisArrays, Unitful\njulia  import Unitful: s, ms, \u00b5s\n\njulia  rng = MersenneTwister(123) # Seed a random number generator for repeatable examples\njulia  fs = 40000 # Generate a 40kHz noisy signal, with spike-like stuff added for testing\njulia  y = randn(rng, 60*fs+1)*3\njulia  for spk = (sin.(0.8:0.2:8.6) .* [0:0.01:.1; .15:.1:.95; 1:-.05:.05] .* 50,\n                  sin.(0.8:0.4:8.6) .* [0:0.02:.1; .15:.1:1; 1:-.2:.1] .* 50)\n           i = rand(rng, round(Int,.001fs):1fs)\n           while i+length(spk)-1   length(y)\n               y[i:i+length(spk)-1] += spk\n               i += rand(rng, round(Int,.001fs):1fs)\n           end\n       end  julia  A = AxisArray([y 2y], Axis{:time}(0s:1s/fs:60s), Axis{:chan}([:c1, :c2]))\n\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time, 0.0 s:2.5e-5 s:60.0 s\n    :chan, Symbol[:c1, :c2]\nAnd data, a 2400001\u00d72 Array{Float64,2}:\n  3.5708     7.14161\n  6.14454   12.2891\n  3.42795    6.85591\n  1.37825    2.75649\n -1.19004   -2.38007\n -1.99414   -3.98828\n  2.9429     5.88581\n -0.226449  -0.452898\n  0.821446   1.64289\n -0.582687  -1.16537\n  \u22ee\n -3.50593   -7.01187\n  2.26783    4.53565\n -0.16902   -0.33804\n -3.84852   -7.69703\n  0.226457   0.452914\n  0.560809   1.12162\n  4.67663    9.35326\n -2.41005   -4.8201\n -3.71612   -7.43224  AxisArrays behave like regular arrays, but they additionally use the axis information to enable all sorts of fancy behaviors. For example, we can specify indices in  any  order, just so long as we annotate them with the axis name:  julia  A[Axis{:time}(4)]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :chan, Symbol[:c1, :c2]\nAnd data, a 2-element Array{Float64,1}:\n 1.37825\n 2.75649\n\njulia  A[Axis{:chan}(:c2), Axis{:time}(1:5)]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 0.0 s:2.5e-5 s:0.0001 s\nAnd data, a 5-element Array{Float64,1}:\n  7.14161\n 12.2891\n  6.85591\n  2.75649\n -2.38007  We can also index by the  values  of each axis using an  Interval  type that selects all values between two endpoints  a .. b  or the axis values directly. Notice that the returned AxisArray still has axis information itself... and it still has the correct time information for those datapoints!  julia  A[40\u00b5s .. 220\u00b5s, :c1]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 5.0e-5 s:2.5e-5 s:0.0002 s\nAnd data, a 7-element Array{Float64,1}:\n  3.42795\n  1.37825\n -1.19004\n -1.99414\n  2.9429\n -0.226449\n  0.821446\n\njulia  axes(ans, 1)\nAxisArrays.Axis{:time,StepRangeLen{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}},Base.TwicePrecision{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}},Base.TwicePrecision{Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}}}}(5.0e-5 s:2.5e-5 s:0.0002 s)  You can also index by a single value on an axis using  atvalue . This will drop a dimension. Indexing with an  Interval  type retains dimensions, even when the ends of the interval are equal:  julia  A[atvalue(2.5e-5s), :c1]\n6.14453912336772\n\njulia  A[2.5e-5s..2.5e-5s, :c1]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 2.5e-5 s:2.5e-5 s:2.5e-5 s\nAnd data, a 1-element Array{Float64,1}:\n 6.14454  You can even index by multiple values by broadcasting  atvalue  over an array:  julia  A[atvalue.([2.5e-5s, 75.0\u00b5s])]\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time, Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}[2.5e-5 s, 7.5e-5 s]\n    :chan, Symbol[:c1, :c2]\nAnd data, a 2\u00d72 Array{Float64,2}:\n 6.14454  12.2891\n 1.37825   2.75649  Sometimes, though, what we're really interested in is a window of time about a specific index. One of the operations above (looking for values in the window from 40\u00b5s to 220\u00b5s) might be more clearly expressed as a symmetrical window about a specific index where we know something interesting happened. To represent this, we use the  atindex  function:  julia  A[atindex(-90\u00b5s .. 90\u00b5s, 5), :c2]\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time_sub, -7.5e-5 s:2.5e-5 s:7.5e-5 s\nAnd data, a 7-element Array{Float64,1}:\n 12.2891\n  6.85591\n  2.75649\n -2.38007\n -3.98828\n  5.88581\n -0.452898  Note that the returned AxisArray has its time axis shifted to represent the interval about the given index!  This simple concept can be extended to some very powerful behaviors. For example, let's threshold our data and find windows about those threshold crossings.  julia  idxs = find(diff(A[:,:c1] .  -15) .  0);\n\njulia  spks = A[atindex(-200\u00b5s .. 800\u00b5s, idxs), :c1]\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time_sub, -0.0002 s:2.5e-5 s:0.0008 s\n    :time_rep, Quantity{Float64, Dimensions:{\ud835\udc13}, Units:{s}}[0.162 s, 0.20045 s, 0.28495 s, 0.530325 s, 0.821725 s, 1.0453 s, 1.11967 s, 1.1523 s, 1.22085 s, 1.6253 s  \u2026  57.0094 s, 57.5818 s, 57.8716 s, 57.8806 s, 58.4353 s, 58.7041 s, 59.1015 s, 59.1783 s, 59.425 s, 59.5657 s]\nAnd data, a 41\u00d7247 Array{Float64,2}:\n  -1.82238     2.3315      -1.56147   \u2026    4.33751     4.77713    -1.81713\n   0.672063    7.25649      0.633375       1.54583     5.81194    -4.706\n  -1.65182     2.57487      0.477408       3.09505     3.52478     4.13037\n   4.46035     2.11313      4.78372        1.23385     7.2525      3.57485\n   5.25651    -2.19785      3.05933        0.965021    6.78414     5.94854\n   7.8537      0.345008     0.960533  \u2026    0.812989    0.336715    0.303909\n   0.466816    0.643649    -3.67087        3.92978    -3.1242      0.789722\n  -6.0445    -13.2441      -4.60716        0.265144   -4.50987    -8.84897\n  -9.21703   -13.2254     -14.4409        -8.6664    -13.3457    -11.6213\n -16.1809    -22.7037     -25.023        -15.9376    -28.0817    -16.996\n   \u22ee                                  \u22f1                \u22ee\n   1.72728     4.77428    -10.3922        -2.08555     1.19198    -1.94365\n  -0.301629    0.0683982   -4.36574        1.92362    -5.12333    -3.4431\n   4.7182      1.18615      4.40717       -4.51757    -8.64314     0.0800021\n  -2.43775    -0.151882    -1.40817   \u2026   -3.38555    -2.23418     0.728549\n   3.2482     -0.60967      0.471288       2.53395     0.468817   -3.65905\n  -4.26967     2.24747     -3.13758        1.74967     4.5052     -0.145357\n  -0.752487    1.69446     -1.20491        1.71429     1.81936     0.290158\n   4.64348    -3.94187     -1.59213        7.15428    -0.539748    4.82309\n   1.09652    -2.66999      0.521931  \u2026   -3.80528     1.70421     3.40583  By indexing with a repeated interval, we have  added  a dimension to the output! The returned AxisArray's columns specify each repetition of the interval, and each datapoint in the column represents a timepoint within that interval, adjusted by the time of the theshold crossing. The best part here is that the returned matrix knows precisely where its data came from, and has labeled its dimensions appropriately. Not only is there the proper time base for each waveform, but we also have recorded the event times as the axis across the columns.", 
            "title": "Example of currently-implemented behavior:"
        }, 
        {
            "location": "/#indexing", 
            "text": "", 
            "title": "Indexing"
        }, 
        {
            "location": "/#indexing-axes", 
            "text": "Two main types of Axes supported by default include:   Categorical axis \u2013 These are vectors of labels, normally symbols or strings. Elements or slices can be selected by elements or vectors of elements.  Dimensional axis \u2013 These are sorted vectors or iterators that can be selected by  Intervals . These are commonly used for sequences of times or date-times. For regular sample rates, ranges can be used.   Here is an example with a Dimensional axis representing a time sequence along rows and a Categorical axis of symbols for column headers.  B = AxisArray(reshape(1:15, 5, 3), .1:.1:0.5, [:a, :b, :c])\nB[Axis{:row}(Interval(.2,.4))] # restrict the AxisArray along the time axis\nB[Interval(0.,.3), [:a, :c]]   # select an interval and two of the columns  User-defined axis types can be added along with custom indexing behaviors.", 
            "title": "Indexing axes"
        }, 
        {
            "location": "/#example-compute-the-intensity-weighted-mean-along-the-z-axis", 
            "text": "B = AxisArray(randn(100,100,100), :x, :y, :z)\nItotal = sumz = 0.0\nfor iter in eachindex(B)  # traverses in storage order for cache efficiency\n    I = B[iter]  # intensity in a single voxel\n    Itotal += I\n    sumz += I * iter[axisdim(B, Axis{:z})]  # axisdim  looks up  the z dimension\nend\nmeanz = sumz/Itotal  The intention is that all of these operations are just as efficient as they would be if you used traditional position-based indexing with all the inherent assumptions about the storage order of  B .", 
            "title": "Example: compute the intensity-weighted mean along the z axis"
        }, 
        {
            "location": "/reference/", 
            "text": "#\n\n\nAxisArrays.Axis\n \n \nType\n.\n\n\nType-stable axis-specific indexing and identification with a parametric type.\n\n\nType parameters\n\n\nstruct Axis{name,T}\n\n\n\n\n\n\nname\n : the name of the axis, a Symbol\n\n\nT\n : the type of the axis\n\n\n\n\nConstructors\n\n\nAxis{name}(I)\n\n\n\n\nArguments\n\n\n\n\nname\n : the axis name Symbol or integer dimension\n\n\nI\n : the indexer, any indexing type that the axis supports\n\n\n\n\nExamples\n\n\nHere is an example with a Dimensional axis representing a time sequence along rows and a Categorical axis of Symbols for column headers.\n\n\nA = AxisArray(reshape(1:60, 12, 5), .1:.1:1.2, [:a, :b, :c, :d, :e])\nA[Axis{:col}(2)] # grabs the second column\nA[Axis{:col}(:b)] # Same as above, grabs column :b (the second column)\nA[Axis{:row}(2)] # grabs the second row\nA[Axis{2}(2:5)] # grabs the second through 5th columns\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.AxisArray\n \n \nType\n.\n\n\nAn AxisArray is an AbstractArray that wraps another AbstractArray and adds axis names and values to each array dimension. AxisArrays can be indexed by using the named axes as an alternative to positional indexing by dimension. Other advanced indexing along axis values are also provided.\n\n\nType parameters\n\n\nThe AxisArray contains several type parameters:\n\n\nstruct AxisArray{T,N,D,Ax} \n: AbstractArray{T,N}\n\n\n\n\n\n\nT\n : the elemental type of the AbstractArray\n\n\nN\n : the number of dimensions\n\n\nD\n : the type of the wrapped AbstractArray\n\n\nAx\n : the names and types of the axes, as a (specialized) NTuple{N, Axis}\n\n\n\n\nConstructors\n\n\nAxisArray(A::AbstractArray, axes::Axis...)\nAxisArray(A::AbstractArray, names::Symbol...)\nAxisArray(A::AbstractArray, vectors::AbstractVector...)\nAxisArray(A::AbstractArray, (names...,), (steps...,), [(offsets...,)])\n\n\n\n\nArguments\n\n\n\n\nA::AbstractArray\n : the wrapped array data\n\n\naxes\n or \nnames\n or \nvectors\n : dimensional information for the wrapped array\n\n\n\n\nThe dimensional information may be passed in one of three ways and is entirely optional. When the axis name or value is missing for a dimension, a default is substituted. The default axis names for dimensions \n(1, 2, 3, 4, 5, ...)\n are \n(:row, :col, :page, :dim_4, :dim_5, ...)\n. The default axis values are \nindices(A, d)\n for each missing dimension \nd\n.\n\n\nIndexing\n\n\nIndexing returns a view into the original data. The returned view is a new AxisArray that wraps a SubArray. Indexing should be type stable. Use \nAxis{axisname}(idx)\n to index based on a specific axis. \naxisname\n is a Symbol specifying the axis to index/slice, and \nidx\n is a normal indexing object (\nInt\n, \nArray{Int,1}\n, etc.) or a custom indexing type for that particular type of axis.\n\n\nTwo main types of axes supported by default include:\n\n\n\n\nCategorical axis \u2013 These are vectors of labels, normally Symbols or strings. Elements or slices can be indexed by elements or vectors of elements.\n\n\nDimensional axis \u2013 These are sorted vectors or iterators that can be indexed by \nClosedInterval()\n. These are commonly used for sequences of times or date-times. For regular sample rates, ranges can be used.\n\n\n\n\nUser-defined axis types can be added along with custom indexing behaviors. To add add a custom type as a Categorical or Dimensional axis, add a trait using \nAxisArrays.axistrait\n.\n\n\nFor more advanced indexing, you can define custom methods for \nAxisArrays.axisindexes\n.\n\n\nExamples\n\n\nHere is an example with a Dimensional axis representing a time sequence along rows (it's a FloatRange) and a Categorical axis of Symbols for column headers.\n\n\nA = AxisArray(reshape(1:15, 5, 3), Axis{:time}(.1:.1:0.5), Axis{:col}([:a, :b, :c]))\nA[Axis{:time}(1:3)]   # equivalent to A[1:3,:]\nA[Axis{:time}(ClosedInterval(.2,.4))] # restrict the AxisArray along the time axis\nA[ClosedInterval(0.,.3), [:a, :c]]   # select an interval and two columns\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.SortedVector\n \n \nType\n.\n\n\nA SortedVector is an AbstractVector where the underlying data is ordered (monotonically increasing).\n\n\nIndexing that would unsort the data is prohibited. A SortedVector is a Dimensional axis, and no checking is done to ensure that the data is sorted. Duplicate values are allowed.\n\n\nA SortedVector axis can be indexed with an ClosedInterval, with a value, or with a vector of values. Use of a SortedVector{Tuple} axis allows indexing similar to the hierarchical index of the Python Pandas package or the R data.table package.\n\n\nConstructors\n\n\nSortedVector(x::AbstractVector)\n\n\n\n\nKeyword Arguments\n\n\n\n\nx::AbstractVector\n : the wrapped vector\n\n\n\n\nExamples\n\n\nv = SortedVector(collect([1.; 10.; 10:15.]))\nA = AxisArray(reshape(1:16, 8, 2), v, [:a, :b])\nA[ClosedInterval(8.,12.), :]\nA[1., :]\nA[10., :]\n\n## Hierarchical index example with three key levels\n\ndata = reshape(1.:40., 20, 2)\nv = collect(zip([:a, :b, :c][rand(1:3,20)], [:x,:y][rand(1:2,20)], [:x,:y][rand(1:2,20)]))\nidx = sortperm(v)\nA = AxisArray(data[idx,:], SortedVector(v[idx]), [:a, :b])\nA[:b, :]\nA[[:a,:c], :]\nA[(:a,:x), :]\nA[(:a,:x,:x), :]\nA[ClosedInterval(:a,:b), :]\nA[ClosedInterval((:a,:x),(:b,:x)), :]\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.axes\n \n \nMethod\n.\n\n\naxes(A::AxisArray) -\n (Axis...)\naxes(A::AxisArray, ax::Axis) -\n Axis\naxes(A::AxisArray, dim::Int) -\n Axis\n\n\n\n\nReturns the tuple of axis vectors for an AxisArray. If an specific \nAxis\n is specified, then only that axis vector is returned.  Note that when extracting a single axis vector, \naxes(A, Axis{1})\n) is type-stable and will perform better than \naxes(A)[1]\n.\n\n\nFor an AbstractArray without \nAxis\n information, \naxes\n returns the default axes, i.e., those that would be produced by \nAxisArray(A)\n.\n\n\nsource\n\n\n#\n\n\nAxisArrays.axisdim\n \n \nMethod\n.\n\n\naxisdim(::AxisArray, ::Axis) -\n Int\naxisdim(::AxisArray, ::Type{Axis}) -\n Int\n\n\n\n\nGiven an AxisArray and an Axis, return the integer dimension of the Axis within the array.\n\n\nsource\n\n\n#\n\n\nAxisArrays.axisnames\n \n \nMethod\n.\n\n\naxisnames(A::AxisArray)           -\n (Symbol...)\naxisnames(::Type{AxisArray{...}}) -\n (Symbol...)\naxisnames(ax::Axis...)            -\n (Symbol...)\naxisnames(::Type{Axis{...}}...)   -\n (Symbol...)\n\n\n\n\nReturns the axis names of an AxisArray or list of Axises as a tuple of Symbols.\n\n\nsource\n\n\n#\n\n\nAxisArrays.axisvalues\n \n \nMethod\n.\n\n\naxisvalues(A::AxisArray)           -\n (AbstractVector...)\naxisvalues(ax::Axis...)            -\n (AbstractVector...)\n\n\n\n\nReturns the axis values of an AxisArray or list of Axises as a tuple of vectors.\n\n\nsource\n\n\n#\n\n\nAxisArrays.collapse\n \n \nMethod\n.\n\n\ncollapse(::Type{Val{N}}, As::AxisArray...) -\n AxisArray\ncollapse(::Type{Val{N}}, labels::Tuple, As::AxisArray...) -\n AxisArray\ncollapse(::Type{Val{N}}, ::Type{NewArrayType}, As::AxisArray...) -\n AxisArray\ncollapse(::Type{Val{N}}, ::Type{NewArrayType}, labels::Tuple, As::AxisArray...) -\n AxisArray\n\n\n\n\nCollapses \nAxisArray\ns with \nN\n equal leading axes into a single \nAxisArray\n. All additional axes in any of the arrays are collapsed into a single additional axis of type \nAxis{:collapsed, CategoricalVector{Tuple}}\n.\n\n\nArguments\n\n\n\n\n::Type{Val{N}}\n: the greatest common dimension to share between all input                   arrays. The remaining axes are collapsed. All \nN\n axes must be common                   to each input array, at the same dimension. Values from \n0\n up to the                   minimum number of dimensions across all input arrays are allowed.\n\n\nlabels::Tuple\n: (optional) an index for each array in \nAs\n used as the leading element in                  the index tuples in the \n:collapsed\n axis. Defaults to \n1:length(As)\n.\n\n\n::Type{NewArrayType\n:AbstractArray{_, N+1}}\n: (optional) the desired underlying array                                                type for the returned \nAxisArray\n.\n\n\nAs::AxisArray...\n: \nAxisArray\ns to be collapsed together.\n\n\n\n\nExamples\n\n\njulia\n price_data = AxisArray(rand(10), Axis{:time}(Date(2016,01,01):Day(1):Date(2016,01,10)))\n1-dimensional AxisArray{Float64,1,...} with axes:\n    :time, 2016-01-01:1 day:2016-01-10\nAnd data, a 10-element Array{Float64,1}:\n 0.885014\n 0.418562\n 0.609344\n 0.72221\n 0.43656\n 0.840304\n 0.455337\n 0.65954\n 0.393801\n 0.260207\n\njulia\n size_data = AxisArray(rand(10,2), Axis{:time}(Date(2016,01,01):Day(1):Date(2016,01,10)), Axis{:measure}([:area, :volume]))\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time, 2016-01-01:1 day:2016-01-10\n    :measure, Symbol[:area, :volume]\nAnd data, a 10\u00d72 Array{Float64,2}:\n 0.159434     0.456992\n 0.344521     0.374623\n 0.522077     0.313256\n 0.994697     0.320953\n 0.95104      0.900526\n 0.921854     0.729311\n 0.000922581  0.148822\n 0.449128     0.761714\n 0.650277     0.135061\n 0.688773     0.513845\n\njulia\n collapsed = collapse(Val{1}, (:price, :size), price_data, size_data)\n2-dimensional AxisArray{Float64,2,...} with axes:\n    :time, 2016-01-01:1 day:2016-01-10\n    :collapsed, Tuple{Symbol,Vararg{Symbol,N} where N}[(:price,), (:size, :area), (:size, :volume)]\nAnd data, a 10\u00d73 Array{Float64,2}:\n 0.885014  0.159434     0.456992\n 0.418562  0.344521     0.374623\n 0.609344  0.522077     0.313256\n 0.72221   0.994697     0.320953\n 0.43656   0.95104      0.900526\n 0.840304  0.921854     0.729311\n 0.455337  0.000922581  0.148822\n 0.65954   0.449128     0.761714\n 0.393801  0.650277     0.135061\n 0.260207  0.688773     0.513845\n\njulia\n collapsed[Axis{:collapsed}(:size)] == size_data\ntrue\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.CategoricalVector\n \n \nType\n.\n\n\nA CategoricalVector is an AbstractVector which is treated as a categorical axis regardless of the element type. Duplicate values are not allowed but are not filtered out.\n\n\nA CategoricalVector axis can be indexed with an ClosedInterval, with a value, or with a vector of values. Use of a CategoricalVector{Tuple} axis allows indexing similar to the hierarchical index of the Python Pandas package or the R data.table package.\n\n\nIn general, indexing into a CategoricalVector will be much slower than the corresponding SortedVector or another sorted axis type, as linear search is required.\n\n\nConstructors\n\n\nCategoricalVector(x::AbstractVector)\n\n\n\n\nArguments\n\n\n\n\nx::AbstractVector\n : the wrapped vector\n\n\n\n\nExamples\n\n\nv = CategoricalVector(collect([1; 8; 10:15]))\nA = AxisArray(reshape(1:16, 8, 2), v, [:a, :b])\nA[Axis{:row}(1), :]\nA[Axis{:row}(10), :]\nA[Axis{:row}([1, 10]), :]\n\n## Hierarchical index example with three key levels\n\ndata = reshape(1.:40., 20, 2)\nv = collect(zip([:a, :b, :c][rand(1:3,20)], [:x,:y][rand(1:2,20)], [:x,:y][rand(1:2,20)]))\nA = AxisArray(data, CategoricalVector(v), [:a, :b])\nA[:b, :]\nA[[:a,:c], :]\nA[(:a,:x), :]\nA[(:a,:x,:x), :]\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.axisindexes\n \n \nMethod\n.\n\n\naxisindexes(ax::Axis, axis_idx) -\n array_idx\naxisindexes(::Type{\n:AxisTrait}, axis_values, axis_idx) -\n array_idx\n\n\n\n\nTranslate an index into an axis into an index into the underlying array. Users can add additional indexing behaviours for custom axes or custom indices by adding methods to this function.\n\n\nExamples\n\n\nAdd a method for indexing into an \nAxis{name, SortedSet}\n:\n\n\nAxisArrays.axisindexes(::Type{Categorical}, ax::SortedSet, idx::AbstractVector) = findin(collect(ax), idx)\n\n\n\n\nAdd a method for indexing into a \nCategorical\n axis with a \nSortedSet\n:\n\n\nAxisArrays.axisindexes(::Type{Categorical}, ax::AbstractVector, idx::SortedSet) = findin(ax, idx)\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.axisparams\n \n \nMethod\n.\n\n\naxisparams(::AxisArray) -\n Vararg{::Type{Axis}}\naxisparams(::Type{AxisArray}) -\n Vararg{::Type{Axis}}\n\n\n\n\nReturns the axis parameters for an AxisArray.\n\n\nsource\n\n\n#\n\n\nAxisArrays.axistrait\n \n \nMethod\n.\n\n\naxistrait(ax::Axis) -\n Type{\n:AxisTrait}\naxistrait{T}(::Type{T}) -\n Type{\n:AxisTrait}\n\n\n\n\nReturns the indexing type of an \nAxis\n, any subtype of \nAxisTrait\n. The default is \nUnsupported\n, meaning there is no special indexing behaviour for this axis and indexes into this axis are passed directly to the underlying array.\n\n\nTwo main types of axes supported by default are \nCategorical\n and \nDimensional\n; see \nIndexing\n for more information on these types.\n\n\nUser-defined axis types can be added along with custom indexing behaviors by defining new methods of this function. Here is the example of adding a custom Dimensional axis:\n\n\nAxisArrays.axistrait(::Type{MyCustomAxis}) = AxisArrays.Dimensional\n\n\n\n\nsource\n\n\n#\n\n\nAxisArrays.default_axes\n \n \nFunction\n.\n\n\ndefault_axes(A::AbstractArray)\ndefault_axes(A::AbstractArray, axs)\n\n\n\n\nReturn a tuple of Axis objects that appropriately index into the array A.\n\n\nThe optional second argument can take a tuple of vectors or axes, which will be wrapped with the appropriate axis name, and it will ensure no axis goes beyond the dimensionality of the array A.\n\n\nsource\n\n\n#\n\n\nAxisArrays.permutation\n \n \nMethod\n.\n\n\npermutation(to, from) -\n p\n\n\n\n\nCalculate the permutation of labels in \nfrom\n to produce the order in \nto\n. Any entries in \nto\n that are missing in \nfrom\n will receive an index of 0. Any entries in \nfrom\n that are missing in \nto\n will have their indices appended to the end of the permutation. Consequently, the length of \np\n is equal to the longer of \nto\n and \nfrom\n.\n\n\nsource\n\n\n#\n\n\nAxisArrays.reaxis\n \n \nMethod\n.\n\n\nreaxis(A::AxisArray, I...)\n\n\n\n\nThis internal function determines the new set of axes that are constructed upon indexing with I.\n\n\nsource\n\n\n#\n\n\nAxisArrays.searchsortednearest\n \n \nMethod\n.\n\n\nsearchsortednearest(vec::AbstractVector, x)\n\n\n\n\nLike \nsearchsortedfirst\n or \nsearchsortedlast\n, this returns the the index of the element in the sorted vector \nvec\n whose value is closest to \nx\n, rounding up. If there are multiple elements that are equally close to \nx\n, this will return the first index if \nx\n is less than or equal to those in the vector or the last index if \nx\n is greater.\n\n\nsource\n\n\n#\n\n\nBase.join\n \n \nMethod\n.\n\n\njoin(As::AxisArray...)\n\n\n\n\nCombines AxisArrays with matching axis names into a single AxisArray. Unlike \nmerge\n, the inputs are joined along a newly created axis (optionally specified with the \nnewaxis\n keyword argument).  The \nmethod\n keyword argument can be used to specify the join type:\n\n\n:inner\n - keep only those array values at axis values common to all AxisArrays to be joined \n:left\n - keep only those array values at axis values present in the first AxisArray passed \n:right\n - keep only those array values at axis values present in the last AxisArray passed \n:outer\n (default) - keep all array values: create an AxisArray spanning all of the input axis values\n\n\nIf an array value in the output array is not defined in any of the input arrays (i.e. in the case of a left, right, or outer join), it takes the value of the optional \nfillvalue\n keyword argument (default zero).\n\n\nsource\n\n\n#\n\n\nBase.merge\n \n \nMethod\n.\n\n\nmerge(As::AxisArray...)\n\n\n\n\nCombines AxisArrays with matching axis names into a single AxisArray spanning all of the axis values of the inputs. If a coordinate is defined in more than ones of the inputs, it takes its value from last input in which it appears. If a coordinate in the output array is not defined in any of the input arrays, it takes the value of the optional \nfillvalue\n keyword argument (default zero).\n\n\nsource", 
            "title": "Reference"
        }
    ]
}